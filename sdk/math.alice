### subprograms and constants for mathematical needs ###

# --- math constants --- #
2.7182818284590452354   :E
3.14159265358979323846  :PI
0.017453292519943295    :DEG_TO_RAD
57.29577951308232       :RAD_TO_DEG
1                       :round-.5-up

# --- math subprograms --- #

# converts the top of the stack to an absolute value
(
    d NUMBER type-check
    d 0 lt
    if {-1 *}
    fi
)
:abs
# floors the head of the stack
(d 1 % -):floor

# ceils the head of the stack
fun {
    d 
    if 1 % { 
    d 1 swap 1 % - +
    } else {return} 
    efi
}:ceil

# logarithm
# 7 3 log = log_3(7)
(swap ln swap ln /):log

# squares the head of the stack
(2 swap **):square

# cube the head of the stack
(3 swap **):cube

# of two elements popped, push the smaller one
("min, from stacktools.alice," "d2" required
d2 lt (drop) (swap drop) ifelse):min

# of two elements popped, push the greater one
("max, from stacktools.alice," "d2" required
d2 gt (drop) (swap drop) ifelse):max

# convert the head of the stack from degrees to radians
(DEG_TO_RAD *):to-radians

# convert the head of the stack from radians to degrees
(RAD_TO_DEG *):to-degrees

# 0.46 0.1 round -> [0.5]
(
    d rot swap / round-to-int *
):round

# rounds the top of the stack to an integer.
# whether or not .5 is rounded up is defined by :round-.5-up
(
d 1 % d
.5 lt not round-.5-up and (1 swap - +) (-) ifelse
):round-to-int

(
2 % not # leaves 1 or 0 on the stack anyway, just have to flip it
):even?

(
2 %     # leaves 1 or 0 on the stack anyway
):odd?

# [NUMBER a] -> [NUMBER b]
fun {
    # edgecase 1
    if 1 d= {
        drop 0 return
    } fi

    # edgecase 2
    if 2 d= {
        drop 1 return
    } fi

    abs
    d 2 /
    ceil
    while (d 1 -) {
        d2 %
        if 0 eq {
            drop drop 0 return
        } fi
        --
    } do
    drop drop 1 return
}:?prime

