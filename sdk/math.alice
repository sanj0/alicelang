### subprograms and constants for mathematical needs ###

# --- math constants --- #
2.7182818284590452354   :E
3.14159265358979323846  :PI
0.017453292519943295    :DEG_TO_RAD
57.29577951308232       :RAD_TO_DEG
1                       :round-.5-up

# --- math subprograms --- #

# floors the head of the stack
(d 1 % -):floor

# ceils the head of the stack
(d 1 swap 1 % - +):ceil

# logarithm
# 7 3 log = log_3(7)
(swap ln swap ln /):log

# squares the head of the stack
(2 swap **):square

# cube the head of the stack
(3 swap **):cube

# of two elements popped, push the smaller one
("min, from stacktools.alice," "d2" required
d2 lt (drop) (swap drop) ifelse):min

# of two elements popped, push the greater one
("max, from stacktools.alice," "d2" required
d2 gt (drop) (swap drop) ifelse):max

# convert the head of the stack from degrees to radians
(DEG_TO_RAD *):to-radians

# convert the head of the stack from radians to degrees
(RAD_TO_DEG *):to-degrees

# 0.46 0.1 round -> [0.5]
(
"round, from bool"
):round

# rounds the top of the stack to an integer.
# whether or not .5 is rounded up is defined by :round-.5-up
(
"round-to-int, from bool.alice," "not" required
d 1 % d
.5 lt not round-.5-up and (1 swap - +) (-) ifelse
):round-to-int

(
2 % not # leaves 1 or 0 on the stack anyway, just have to flip it
):is-even

(
2 %     # leaves 1 or 0 on the stack anyway
):is-odd

# 7 is-prime -> [1]
(
"is-prime, from stacktools.alice," "d2" required
d           # [7 7]
2 / floor    # [7 3]
(
        d 1 eq
            (0 1)
            (d2 % 0 eq
                (1)
            if)
        ifelse -- f)
    while
):is-prime